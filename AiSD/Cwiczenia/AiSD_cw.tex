\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[polish]{babel}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{float}
\usepackage{graphicx}

\title{Algorytmy i Struktury Danych - ćwiczenia}
\author{Wojciech Typer}
\date{}

\begin{document}
\maketitle
\textbf{zadanie 1/ lista1} \par
Zadanie sprowadza się do znalezenia najmniejszego n, 
takiego, że: \par
$44n^2 < 2^n$ \par
najmniejszym takim n jest $n = 13$ \par
indukcyjnie można pokazać, że dla każdych następnych n \par
nierówność dalej będzie zachowana: \par
zał: $44n^2 < 2^n$ \par
krok indukcyjny: \par
$44(k + 1)^2 < 2^{k + 1}$ \par
$44(k^2 + 2k + 1) < 2^k * 2$ \par
$44k^2 + 88k + 44 < 2^k * 2$ \par
z założenia mamy, że: $44k^2 < 2^k$ \par
więc musimy pokazać, że: $88k + 44 < 2^k (k \geq 13)$ \par
Ten fragment jest już bardzo łatwo udowodnić indukcyjnie.  \par

\vspace{1\baselineskip}
\textbf{zadanie 2/ lista1} \par
znając $f(n) = t$, musimy znależć n \par
przeliczmy jednostki czasu na mikrosekundy: \par
$1s = 10^6 \mu s$, $30min = 1.8 * 10^9 \mu s$ i $1 wiek = 3.1 * 10^{15} \mu s$\par
zatem: \par
$log_{10}(n) = 10^6  \rightarrow n = 10^{60},$ \par $ log_{10}(n) = 1.8 * 10^9  \rightarrow n = 10^1.8 * 10^9,$ \par $ log_{10}(n) = 3.1 * 10^{15}  \rightarrow n = 10^3.1 * 10^{15}$ \par
$\sqrt{n} = 10^6  \rightarrow n = 10^{12}, \sqrt{n} = 1.8 * 10^9  \rightarrow n = 3.24 * 10^{18},$ \par $ \sqrt{n} = 3.1 * 10^{15}  \rightarrow n = 9.61 * 10^{30}$ \par
$2^n = 10^6  \rightarrow n = 19, 2^n = 1.8 * 10^9  \rightarrow n = 30.7, 2^n = 3.1 * 10^{15}  \rightarrow n = 51$ \par
$n! = 10^6  \rightarrow n = 9, n! = 1.8 * 10^9  \rightarrow n = 13, n! = 3.1 * 10^{15}  \rightarrow n = 18$ \par

\vspace{1\baselineskip}
\textbf{zadanie 3/ lista1} \par
1. $e^{\pi}   \rightarrow O(1)$ \par
2. $7(log_{10}(n))^7  \rightarrow O((log(n))^7)$ \par
3. $\sqrt{2\pi n}  \rightarrow O{\sqrt{n}}$ \par
4. $13n + 13  \rightarrow O(n)$ \par
5. $44n^2 * log(n)  \rightarrow O(n^2 * log(n))$ \par
6. $10^n  \rightarrow O(10^n)$ \par
7. $33^n  \rightarrow O(33^n)$ \par 

\textbf{zadanie 1/ lista2} \par
\begin{tikzpicture}[level distance=1.5cm,
    level 1/.style={sibling distance=6cm},
    level 2/.style={sibling distance=3cm},
    level 3/.style={sibling distance=1.5cm}]
    
  \node {f(27)}
      child {node {f(9)}
          child {node {f(3)}
              child {node {f(1)}}
              child {node {f(1)}}
          }
          child {node {f(3)}
              child {node {f(1)}}
              child {node {f(1)}}
          }
      }
      child {node {f(9)}
          child {node {f(3)}
              child {node {f(1)}}
              child {node {f(1)}}
          }
          child {node {f(3)}
              child {node {f(1)}}
              child {node {f(1)}}
          }
      };
  \end{tikzpicture}
    \par
    \vspace{1\baselineskip}
    Funkcja f(n) dwukrotnie wywołuje samą siebie dla n/3. Drzewo rekurencji  \par
    dla $n = 3^3$ zostało przedstawione powyżej. \par
    Funkcja dzieli n przez 3 w każdym kroku, aż do osiągnięcia n = 1. \par
    Głębokość drzewa rekurencji wynosi zatem: $log_3(n)$ \par
    Na każdym poziomie drzewa liczba wywołań funkcji się podwaja, \par
    i idąć od góry jest to: $2^0 + 2^1 + 2^2 + ... + 2^{log_3(n)}$ \par
    co daje: $2^{log_3(n) + 1} - 1$ \par
    zatem złożoność obliczeniowa wynosi: $O(2^{log_3(n)})$ \par
    \vspace{1\baselineskip}
    \textbf{zadanie 2/ lista2} \par
    $h(n) = \Theta(p(n))$, jeśli istnieją takie stałe $c_1, c_2, n_0 $, że: \par
    dla każdego $n$ zachodzi: \par
    $c_1p(n) \leq h(n) \leq c_2p(n)$ \par
    i $\exists n_0$ takie, że $f(n_0)$ i $g(n_0)$ są dodatnie. \par
    \par
    Zauważmy przy tym, że funkcje $f$ i $g$ są niemalejące oraz asymptotycznie \par nieujemne, tzn. istnieje $n_0$, takie że dla każdego $n \geq n_0$ zachodzi \par $f(n) \geq 0$ oraz $g(n) \geq 0$. \par
    \par
    \vspace{1\baselineskip}
    Wtedy: \par
    $\forall n \geq n_0$ zachodzi: $f(n) \geq f(n_0)$ i $g(n) \geq g(n_0)$. \par 
    \par
    Musimy pokazać, że: $max(f(n), g(n)) = \Theta(f(n) + g(n))$. \par
    \par
    \vspace{1\baselineskip}
    \textbf{Ograniczenie z góry:} \par
    $max(f(n), g(n)) \leq f(n) + g(n)$. \par
    \par
    Największa z dwóch liczb $f(n)$ i $g(n)$ nigdy nie przekroczy ich sumy, \par
    czyli mamy ograniczenie górne: $max(f(n), g(n)) = 1 \cdot (f(n) + g(n))$, \par
    czyli możemy przyjąć $c_2 = 1$. \par
    \par
    \vspace{1\baselineskip}
    \textbf{Ograniczenie z dołu:} \par
    $max(f(n), g(n)) \geq \frac{1}{2} \cdot (f(n) + g(n))$. \par
    \par
    Ponieważ jeśli $f(n) \geq g(n)$ to $f(n) \geq \frac{1}{2}(f(n) + g(n))$, \par
    więc możemy przyjąć $c_1 = \frac{1}{2}$. \par
    \par
    Zatem istnieją stałe $c_1$, $c_2 \geq 0$, spełniające definicję $\Theta$, \par
    więc $max(f(n), g(n)) = \Theta(f(n) + g(n))$. \par
    \par
    c.n.w \par
    \vspace{1\baselineskip}
    \textbf{zadanie 3/ lista2} \par
    1. $P(i, j) = O(1)$ \par
    Złożoność pętli wewnętrzenj while: $O(n - 1)$ \par
    Złożoność pętli zewnętrznej for to: $\sum_{i = 1}^{n} O(n-1)$ \par
    Jest to suma ciągu arytmetycznego $\frac{(n-1)n}{2} = O(n^2)$ \par
    Zatem złożoność algorytmu to: $O(n^2)$ \par
    \vspace{1\baselineskip}
    2. $R(i, j) = O(j)$ \par
    $R(i, j) = \Theta (j)$ \par
    $\sum_{i=1}^{n} \sum_{k=1}^{\log_2{\frac{n}{i}}} \Theta(2^k \cdot i) = \sum_{i=1}{n} \cdot \Theta (i) \cdot \sum_{k=1}^{\log_2{\frac{n}{i}}} \cdot 2^k $\par
    $= \sum_{i=1}^{n} \Theta ((\frac{1 - 2^{log_2 \frac{n}{i}} \cdot 2}{-1} -1)i)$ \par
    $= \sum_{i=1}^{n} \Theta ((-(1- \frac{n}{i}) - 1) i)$ \par
    $= \sum_{i=1}^{n} \Theta (\frac{n}{2} - 2i)$ \par
    $= \Theta (\sum_{i=1}^{n} (\frac{n}{2} - 2i))$ \par
    $= \Theta (\sum_{i=1}^{n} \frac{n}{2} - \sum_{i=1}^{n} 2i)$ \par
    $= \Theta (\frac{n^2}{2} - 2 \cdot \frac{i(n+1)}{2})$ \par
    $= \Theta (\frac{n^2}{2} - \frac{2n^2 + 2n}{2})$ \par
    $= \Theta (- \frac{n^2}{2} - n)$ 





    \vspace{1\baselineskip}
    \textbf{Przypomnienie Master Theorem:} \par
    \vspace{1\baselineskip}
    $T(n) = aT(\frac{n}{b}) + \Theta(n^d)$ \par
    gdzie: 
    \begin{itemize}
        \item a $\rightarrow$ liczba podproblemów w rekursji \par
        \item b $\rightarrow$ współczynnik zmniejszenia rozmiaru problemu \par
        \item d $\rightarrow$ wykładnik w potędze n kosztu pracy poza rekurencją \par
    \end{itemize} \par
    Wówczas: \par
    \begin{itemize}
        \item $\Theta(n^d)$, jeśli $d > log_b(a)$ \par
        \item $\Theta(n^d \cdot log(n))$, jeśli $d = log_b(a)$ \par
        \item $\Theta(n^{log_b(a)})$, jeśli $d < log_b(a)$ \par
    \end{itemize} \par
    \vspace{10\baselineskip}
    \textbf{zadanie 4/ lista2} \par
    \vspace{1\baselineskip}
    \begin{itemize}
        \item $T(n) = 2T(\frac{n}{2}) + 1$ \par
        a = 2, b = 2, d = 0 \par
        $log_2(2) = 1$ \par
        $d < log_b(a)$ \par
        Zatem z zasady Master Theorem: \par
        $T(n) = \Theta(n^{log_b(a)}) = \Theta(n)$ \par
        \item $T(n) = 2T(\frac{n}{2}) + n$ \par
        a = 2, b = 2, d = 1 \par
        $log_b(a) = log_2(2) = 1$ \par
        $log_b(a) = d$ \par
        Zatem z zasady Master Theorem: \par
        $T(n) = \Theta(n \cdot log(n))$ \par
        \item $T(n) = 3T(\frac{n}{2}) + n \cdot log(n)$ \par
        a = 3, b = 2, f(n) = n $\cdot log(n)$ \par
        $log_2(3) \approx 1.58$ \par
        Teraz porównajmy tempo wzrostu licząc granicę: $\lim_{n \to \infty} \frac{n^{log_2(3)}}{n \cdot log(n)}$ \par
        $lim_{n \to \infty} \frac{n^{0.58}}{log(n)}$ \par
        Z zasady de l'Hospitala: \par
        $lim_{n \to \infty} \frac{0.58n^{-0.42}}{\frac{1}{n}}$ \par
        $lim_{n \to \infty} 0.58n^{0.58} = \infty$ \par
        Zatem widzimy, że $n^{log_b(a)}$ rośnie szybciej niż $f(n)$ \par
        Zatem z zasady Master Theorem: \par
        $T(n) = \Theta(n^{log_2(3)}) = \Theta(n^{1.58})$ \par

        \vspace{14\baselineskip}
        \textbf{Zadanie 5} \par
        W tablicy B przechowujemy sumę elementów z tablicy A do indeksu i; \par
        Załóżmy, że A = [5, 6, 7, 8, 9, 1] \par
        Wówczas B = [5, 11, 18, 26, 35, 36] \par
        Tablicę B możemy stworzyć jako: \par
        for i = 2..n { \par
            B[i] = B[i - 1] + A[i] \par
        } \par
        Anser(a, b) { \par
            return B[b] - B[a - 1] \par
        } \par
        Czas wykonania algorytmu jest stały; O(1) \par
        
        \vspace{1\baselineskip}
        \textbf{zadanie 6} \par
        %\begin{figure}[H]
         %   \centering
          %  \includegraphics[width=1.3\textwidth]{/home/wojteq18/Obrazy/Screenshots/Screenshot From 2025-03-26 13-51-45.png}
           % \label{fig:example_image}
        %\end{figure}
        Korzystamy z takiego algorytmu, którego złożoność obliczeniowa to : $O(3^{log_2(n)})$ \par
    \end{itemize}

    \vspace{1\baselineskip}
    \textbf{zadanie 5 / lista 3} \par
    \begin{itemize}
        \item $T(n) = 5T(\frac{n}{2}) + \Theta(n \cdot logn)$ \par
         $T'(n) = 5T'(\frac{n}{2}) + n^{\log_2{5}}$ \par
         z MT: $n \cdot logn = O(n^{log_2{5}})$ \par
         Zatem: $T(n) = O(T'(n))$ \par
         $T''(n) = 5T''(\frac{n}{2}) + n$ \par
         $log_2{5} > 1 \rightarrow T''(n) = \Theta(n^{log_2{5}})$ \par
         $T(n) = \Omega(T''(n))$ \par

         \item $T(n) = 2T(n-1) + \Theta(1)$ \par
         $T(n) = \sum_{i=1}^n 2^i = \Theta(2^n)$ \par

         \item $T(n) = 9T(\frac{n}{3}) + \Theta(n^2)$
         Z MT: $\Theta(n^2 \cdot logn)$ \par
    \end{itemize}
    Widzimy, że najlepszą opcją bedzie wybór algorytmu nr 1
    \newpage
    \textbf{zadanie 3 / lista 4} \par
    Na początku stwórzmy funkcję pomocniczą, wyznaczającą medianę \par jednej
        if n mod 2 == 0 return 0.5 $\cdot$ (C[n/2] + C[n/2 + 1]) \par
        else return C[$\lceil n/2 \rceil$] \par

    \vspace{1\baselineskip}
    Teraz zapiszmy funkcję spełniającą wymogi zadania: \par
    SortedArraysMedian(A[1..n], B[1..n], n) \par
    if n == 1 return 0.5 $\cdot$ (A[1] + B[1]) \par
    if n == 2 return 0.5 $\cdot$ (max(A[1], B[1]) + min(A[2], B[2])) \par
    medianA = Median(A[1..n], n) \par
    medianB = Median(B[1..n], n) \par
    if medianA == medianB return medianA \par
    else if medianA < medianB return SortedArraysMedian($A [\lfloor n/2 \rfloor$ + 1..n] , \par B[$1..n- \lfloor n/2 \rfloor$], n - $\lfloor n/2 \rfloor$) \par
    else return SortedArraysMedian($A [1..n - \lfloor n/2 \rfloor$], B[$\lfloor n/2 \rfloor$ + 1..n], n - $\lfloor n/2 \rfloor$) \par
    
\end{document}